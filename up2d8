#!/usr/bin/env bash
#
# Updates single-file CLI tools (like docker-compose) to the latest version available on the web
#
# Requires:
# - git
# - curl

VERSION="1.0.0"

# ARG_OPTIONAL_SINGLE([dir], [d], [directory to install into])
# ARG_OPTIONAL_SINGLE([bin], [], [dir to link binary to - should be in the PATH])
# ARG_POSITIONAL_INF([commands], [commands to update])
# ARG_HELP([Updates commands to the latest version available on the web])
# ARG_VERSION([echo "up2d8 (bash) version $VERSION"])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='dhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_commands=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_dir=
_arg_bin=

print_help ()
{
	printf '%s\n' "Updates commands to the latest version available on the web"
	printf 'Usage: %s [-d|--dir <arg>] [--bin <arg>] [-h|--help] [-v|--version] [<commands-1>] ... [<commands-n>] ...\n' "$0"
	printf '\t%s\n' "<commands>: commands to update"
	printf '\t%s\n' "-d,--dir: directory to install into (no default)"
	printf '\t%s\n' "--bin: dir to link binary to - should be in the PATH (no default)"
	printf '\t%s\n' "-h,--help: Prints help"
	printf '\t%s\n' "-v,--version: Prints version"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_dir="$2"
				shift
				;;
			--dir=*)
				_arg_dir="${_key##--dir=}"
				;;
			-d*)
				_arg_dir="${_key##-d}"
				;;
			--bin)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_bin="$2"
				shift
				;;
			--bin=*)
				_arg_bin="${_key##--bin=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo "up2d8 (bash) version $VERSION"
				exit 0
				;;
			-v*)
				echo "up2d8 (bash) version $VERSION"
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


assign_positional_args ()
{
	_positional_names=()
	_our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names+=("_arg_commands[$((ii + 0))]")
	done

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# mapping of commands to repos: used to determine latest version available remotely
declare -A repos
# mapping of commands to download filename patterns: used to download latest version
# (please use single quotes to defer any interpretation)
declare -A releases
# mapping of options to get version number: used to determine local version
declare -A versions
declare -A versions_pattern

# each command needs an entry in the 3 arrays defined above

repos["ctop"]='https://github.com/bcicen/ctop'
# https://github.com/bcicen/ctop/releases/download/v0.7.1/ctop-0.7.1-linux-amd64
releases["ctop"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-${_VERSION}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64"'
versions["ctop"]=' -v'
versions_pattern["ctop"]='s/.*version \(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

repos["docker-compose"]='https://github.com/docker/compose'
# little trick here, for version 0.12.2 tag is v0.12.2 (notice leading v)
releases["docker-compose"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s | tr '[:upper:]' '[:lower:]'`-`uname -m`"'
versions["docker-compose"]='--version'
versions_pattern["docker-compose"]='s/.*version \(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

repos["docker-machine"]='https://github.com/docker/machine'
# little trick here, for version 0.12.2 tag is v0.12.2 (notice leading v)
releases["docker-machine"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s | tr '[:upper:]' '[:lower:]'`-`uname -m`"'
versions["docker-machine"]='--version'
versions_pattern["docker-machine"]='s/.*version \(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

repos["helm"]='https://github.com/kubernetes/helm'
releases["helm"]='https://storage.googleapis.com/kubernetes-helm/helm-v${_VERSION}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64.tar.gz'
versions["helm"]='version --client --short'
versions_pattern["helm"]='s/.*v\(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

repos["kompose"]='https://github.com/kubernetes/kompose'
# kompose has 3 tweaks: 0.12.2 is v0.12.2, ends with amd64, and uname is lowercase only
releases["kompose"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64"'
versions["kompose"]='version'
versions_pattern["kompose"]='s/^\(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

# kubectl uses a version file, not repo tags
repos["kubectl"]='https://storage.googleapis.com/kubernetes-release/release/stable.txt'
# https://storage.googleapis.com/kubernetes-release/release/v1.10.0/bin/linux/amd64/kubectl
releases["kubectl"]='"https://storage.googleapis.com/kubernetes-release/release/v${_VERSION}/bin/`uname -s | tr '[:upper:]' '[:lower:]'`/amd64/${_CMD}"'
versions["kubectl"]='version --client --short'
versions_pattern["kubectl"]='s/.*v\(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

repos["minikube"]='https://github.com/kubernetes/minikube'
releases["minikube"]='"${_REPO}/releases/download/v${_VERSION}/${_CMD}-`uname -s | tr '[:upper:]' '[:lower:]'`-amd64"'
versions["minikube"]='version'
versions_pattern["minikube"]='s/.*v\(\([0-9]\+\)\(\.[0-9]\+\)\+\).*/\1/p'

ACTION_NOTHING='do nothing'
ACTION_INSTALL='install'
ACTION_UPDATE='update'

# decides which action to perform for the specified args: nothing, update, or install
# $1 is command to update (must be directly invokable, accept a --version option,
# and return a parseable version in its output)
# $2 is the repo to query
#
# sets
# - ACTION
# - TARGET_VERSION
decide_action() {
  CMD=$1
  REPO=$2
  TARGET_VERSION=$3
#  if [ "$CMD" == 'ctop' ]; then
#    echo "target is '$TARGET_VERSION'"
#    exit 99
#  fi
  # todo crash if missing an arg
  if [ -z "$TARGET_VERSION" ]; then
    # fetch semver from remote source.
    # 2 possibilities: either list tags from a repo, or fetch an exact match from a remote file.
    _remote_repo=`git ls-remote $REPO 2>&1`
    if [ "$?"  = "0" ]; then
      # we're in a git repo, so let's fetch list of tags then determine latest version.
      # This is slightly complex: 1.10.0 is preferred to 1.9.1 in semver, but incorrectly sorted by a naive 'sort' function...
      # so we have to fetch all tags, then pad all their version elements to 3 digits, sort, keep 1, then de-pad properly.
      TARGET_VERSION=`git ls-remote $REPO | grep refs/tags | grep -oP "[0-9]+\.[0-9]+\.[0-9]+$" | sed -e 's/\b[0-9]\b/00&/g; s/\b[0-9]\{2\}\b/0&/g' | sort | tail -n 1 | sed -e 's/\b0*\([1-9]*[0-9]\)\b/\1/g'`
    else
      # not in a git repo, expect the URL is a file containing just the version itself - might include some vX.Y.Z, extract just X.Y.Z
      TARGET_VERSION=`curl -s "$REPO" | grep -oP "[0-9]+\.[0-9]+\.[0-9]+$"`
    fi
  fi
  if [ -z "$TARGET_VERSION" ]; then
    echo "Unable to determine target version to download for '$CMD' in repo '$REPO', this is a fatal bug. Please report it to the author."
    exit 1
  fi
  if [ `which $CMD` ]; then
    _version_toggle=${versions["$CMD"]}
    if [ -z "$_version_toggle" ]; then
      echo "Missing version command for '$CMD', this is a fatal bug. Please report it to the author."
      exit 1
    fi
#    CURRENT_VERSION=`$CMD $_version_toggle`
    CURRENT_VERSION=`$CMD $_version_toggle | sed -n "${versions_pattern["$CMD"]}"`
    if [ -z "$CURRENT_VERSION" ]; then
      echo "Unable to parse version output for '$CMD', this is a fatal bug. Please report it to the author."
      exit 1
    fi
    if [ "$CURRENT_VERSION" == "$TARGET_VERSION" ]; then
      ACTION=$ACTION_NOTHING
    else
      ACTION=$ACTION_UPDATE
    fi
  else
    CURRENT_VERSION='not installed'
    ACTION=$ACTION_INSTALL
  fi
  echo "local $CMD is $CURRENT_VERSION, target is $TARGET_VERSION => $ACTION"
}

# downloads command $1 version $2 from repo $3 into dir $4
download() {
  _CMD=$1
  _VERSION=$2
  _REPO=$3
  _dir=$4
  filenamePattern=${releases["$_CMD"]}
  eval "_URL=$filenamePattern"
  echo "... download $_URL into $_dir"
  mkdir -p "$_dir"
  _CURL=`curl --fail -L $_URL -o $_dir/$_CMD.tmp`
  if [ $? -ne 0 ]; then
    echo "ERROR: unable to download specified version, please check that url is valid: $_URL"
#    rm "$_dir/$_CMD.tmp"
  else
    # special case: .tar.gz files...
    if [[ "$_URL" == *.tar.gz ]]; then
      _file_archive="$_dir/$_CMD.tar.gz"
      # set proper extension on filename
      mv "$_dir/$_CMD.tmp" "$_file_archive"
      # find file matching command name and extract WITHOUT folders
      tar -zxf "$_file_archive" --directory="$_dir" --no-anchored $_CMD --transform='s/.*\///'
      # now remove the archive file
      rm "$_file_archive"
    else
      # all ok, we can replace existing
      chmod +x "$_dir/$_CMD.tmp"
      mv "$_dir/$_CMD.tmp" "$_dir/$_CMD"
    fi
  fi
}


# handle args

commands=("${_arg_commands[@]}")
# defaults to all installed commands
if [ ${#commands[@]} -eq 0 ]; then
  # loop through defined commands
  for cmd in "${!repos[@]}"; do
    which $cmd > /dev/null 2>&1 && commands+=($cmd)
  done
fi

for x in "${commands[@]}"
do
  command_to_up=${x%%=*}
  # this next line is needed to handle the case when we have only the app, no :tag.
  version_to_up=${x##$command_to_up}
  version_to_up=${version_to_up##*=}

  repo=${repos["$command_to_up"]}
  # if no repo, crash
  if [ -z "$repo" ]; then
    echo "Unable to determine repo to query for command '$command_to_up', are you sure this is a valid one?"
    exit 1
  fi

  # trigger update
  decide_action $command_to_up $repo $version_to_up

  case "$ACTION" in
    $ACTION_INSTALL)
      # we manually replace leading ~ with $HOME, otherwise quoting wreaks havoc on the dirs
      # (as mkdir "~/dir" creates a subdir "~" in the current folder)
      dir="${_arg_dir/#~/$HOME}"
      if [ -z "$dir" ]; then
        echo "directory parameter is mandatory to install a new command, please re-run with --dir <install_dir>"
        exit 1
      fi
      # same here, substitute leading ~ to enable defensive quoting
      bin="${_arg_bin/#~/$HOME}"

#      echo "download $command_to_up $TARGET_VERSION $repo $dir"
#      exit 99

      download $command_to_up $TARGET_VERSION $repo $dir
      if [ -n "$bin" ]; then
        echo "... link to $bin/$command_to_up"
        mkdir -p $bin
        ln -sf "$dir"/$command_to_up "$bin"
      fi
      ;;
    $ACTION_UPDATE)
      full_cmd=`which $command_to_up`
      if [ -L "$full_cmd" ]; then
        dir=`dirname \`readlink $full_cmd\``
        # if the link points to a relative dir, we need to prepend with link dir itself
        if [[ "$dir" == .* ]]; then
          dir="`dirname $full_cmd`/$dir"
        fi
      else
        dir=`dirname $full_cmd`
      fi
      download $command_to_up $TARGET_VERSION $repo $dir
      ;;
  esac
done

# ] <-- needed because of Argbash
